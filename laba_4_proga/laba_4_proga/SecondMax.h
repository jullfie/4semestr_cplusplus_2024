// SecondMax.h
#pragma once // Гарантирует, что заголовочный файл будет включен только один раз при компиляци
#include <limits> // Подключение библиотеки для использования std::numeric_limits

// Объявление шаблонной функции findSecondMaximum
template<typename T>
int findSecondMaximum(T* arr, int size) {

    // Проверка, достаточно ли элементов в массиве для нахождения второго максимума
    if (size < 2) {
        return -1;                      // Возвращаем -1, если в массиве меньше двух элементов
    }

    // Инициализация переменной для хранения максимального значения, исходно установленного в минимально возможное значение для типа T
    T firstMax = std::numeric_limits<T>::min();
    // Инициализация переменной для хранения второго максимального значения, аналогично установленного в минимально возможное значение для типа T
    T secondMax = std::numeric_limits<T>::min();

    // Цикл по всем элементам массива
    for (int i = 0; i < size; ++i) {
        
        if (arr[i] > firstMax) {                // Если текущий элемент больше первого максимума 
            secondMax = firstMax;               // Присваиваем текущее значение второго максимума первому максимуму
            firstMax = arr[i];                  // Обновляем первый максимум текущим элементом
        }
        
        else if (arr[i] > secondMax && arr[i] < firstMax) {     // Если элемент больше второго максимума и меньше первого максимума                              
            secondMax = arr[i];                                 // Обновляем второй максимум текущим элементом
        }
    }

    // После определения второго максимума, цикл для нахождения его индекса
    for (int i = 0; i < size; ++i) {
        if (arr[i] == secondMax) {              // Если находим элемент, равный второму максимуму
            return i;                           // Возвращаем его индекс
        }
    }

    // Если второй максимум так и не был найден, возвращаем -1
    return -1;
}
